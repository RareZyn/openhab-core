Chapter 4
Reengineering

WIF3005 Softw re M inten nce nd Evolution

a

a

a

a

a

a

a

Prep red by Dr. N suh

What and why?
• De nitions
• Goals
• Objectives

fi

2

What and Why?
De inition
Reengineering is the examination, analysis, and restructuring of an existing software
system to reconstitute it in a new form, and the subsequent implementation of the
new form.
Software reengineering is the analysis and alteration of an operational system to represent it in a new form and to
obtain a new implementation from the new form. Here, a new form means a representation at a higher level of
abstraction.
- by Chikofsky and Cross II

Reengineering of a software system is a process for creating a new software from an existing software so that the new system is
better than the original system in some ways.
- by Byrne

Reengineering of a software system is an activity that: (i) improves the comprehension of the software system, or (ii) raises the
quality levels of the software, namely, performance, reusability, and maintainability.
- by Arnold
f

3

What and Why?
Go ls

• understand the existing software system artifacts, namely,
speci cation, design, implementation, and documentation, and
• improve the functionality and quality attributes of the system.

fi

a

4

What and Why?
Objectives

Software systems are reengineered by keeping one or more of the
following four general objectives in mind:
• Improving maintainability.
• Migrating to a new technology.
• Improving quality.
• Preparing for functional enhancement.

5

Reengineering Concepts

fi

fi

• Abstraction, Re nement
• Levels of Abstraction and Re nement
• Forward Engineering
• Reverse Engineering
• Alteration
• Reengineering principles

Reengineering Concepts
Abstr ction nd Re inement

Conceptual

Re

Ab

t

Design

Implementation

f

f

fi

f

f

a

a

Figure 4.1 Levels of abstraction and re nement, IEEE, 1992
fi

en

m

Requirements

ne

st
ra
ct
io

n

The ideas of abstraction and re inement
are applied in constructing software
development models, presenting them as a
series of stages correspond to speci ic
levels of abstraction and re inement

Reengineering Concepts
Abstr ction nd Re inement

Abstraction enables software
maintenance personnel to reduce the
complexity of understanding a system by:
1. Focusing on the more signi icant
information about the system
2. Hiding irrelevant details at the moment
Conceptual

Ab

Design

Implementation
Figure 4.1 Levels of abstraction and re nement, IEEE, 1992
f

fi

f

a

f

a

fi

f

t

en

m

Requirements

ne

st
ra
ct
io

n

Re

Re inement is the reverse of abstraction
Principle of abstraction
The level of abstraction of
a system can be gradually
increased by successively
replacing the details with
abstract information. By
means of abstraction one
can produce a view that
focuses on selected
system characteristics by
hiding information about
other characteristics

Principle of re inement
The level of abstraction the
representation of the system
is gradually decreased by
successively replacing some
aspects of the system with
more details.

Reengineering Concepts
Forward Engineering

A new software is created by going downward from the top, highest level of abstraction to the
bottom, lowest level. The downward movement is known as forward engineering.
Forward engineering follows a sequence of activities: formulating the concepts about the system
to identifying requirements to designing the system to implementing the design

r
Fo
rd
wa

Conceptual

En
ne
gi
g
in

er

Requirements

e
(R
ne
t)

en

m

Design

Implementation

fi

fi

Figure 4.1 Levels of abstraction and re nement, IEEE, 1992

Reengineering Concepts
Reverse Engineering

Upward movement through the layers of abstractions is called reverse engineering.
1.
2.

Reverse engineering of a software systems is a process comprising the following steps:
Analyse the software to determine its components and the relationships among the
components
Represent the system at a higher level of abstraction or in another form
Decompilation is an example of Reverse Engineering, in which object code is translated into a
high-level program.

n)
(A
bs

t)

en

rin
se
E

Implementation

fi

Figure 4.1 Levels of abstraction and re nement, IEEE, 1992
fi

m

Design

ne

Re
ve
r

e
(R

ng

in

g
in

er

Requirements

ne
gi

g

En

ee

rd
wa

tr
ac
tio

r
Fo
Conceptual

Reengineering Concepts
Alter tion
Alteration serves as a fundamental pillar in many reengineering methods
Principle of alteration
The making of some changes to a system representation is known as alteration.
Alteration does not involve any change to the degree of abstraction, and it does not
involve modi ication, deletion, and addition of information.

Alteration

Ab

t

en

m

st
ra
ct
io

ne

n

Re

Existing System

Target System

f

a

fi

Figure 4.2 Conceptual basis for the reengineering process, IEEE, 1992

Reengineering Concepts
Reengineering principles

Alteration

Reengineering principles are represented by means of arrows. Abstraction is
represented by an up-arrow, alteration is represented by a horizontal arrow, and
re inement by a down-arrow.
The arrows depicting re inement and abstraction are slanted, thereby
indicating the increase and decrease, respectively, of system information.

Ab

t

en

m

st
ra
ct
io

ne

n

Re
It may be noted that alteration is non-essential for
reengineering

Existing System

Target System

f

fi

f

Figure 4.2 Conceptual basis for the reengineering process, IEEE, 1992

Reengineering Process
• Types of Change
• Reengineering Strategies
• Reengineering Process Variations
• Reengineering Approaches

Software Reengineering Model

(Alteration)

Gener l Model

Re-think

n)
tr
ac
tio
bs
(A
in

g(

gi

in

ne

er

er

ne

gi

Requirements

En

g

rd
wa

Requirements

Re-specify

r
Fo

Conceptual

Conceptual

Eric J. Byrne suggests
that reengineering is a
sequence of 3 activities:
Reverse engineering,
re-design, and forward
engineering

Design

Implementation

Re-code

Implementation

t)

en

m

Re
ve
r

ne

se

En

Re-design

Re

Design

Existing System
fi

a

Figure 4.3 General model of software reengineering, IEEE, 1992

Target System

(Alteration)

Reengineering Process
Types of Ch nge

Re-think

n)
tr
ac
tio
bs
(A
in

g(

gi

in

ne

er

er

ne

gi

Requirements

En

g

rd
wa

Requirements

Re-specify

r
Fo

Conceptual

Conceptual

Eric J. Byrne suggests
that reengineering is a
sequence of 3 activities:
Reverse engineering,
re-design, and forward
engineering

Design

Implementation

Re-code

Implementation

t)

en

m

Re
ve
r

ne

se

En

Re-design

Re

Design

Existing System
fi

a

Figure 4.3 General model of software reengineering, IEEE, 1992

Target System

Reengineering Process
Re-code

(Alteration)

* Implementation characteristics of the source program

Re-think

are changed by re-coding it. Source code level changes
are performed by means of rephrasing and program
translation.
* A program is transformed into a program in a di erent
language. While rephrasing keeps the program in the
same language
* Translation scenarios : compilation, decompilation,
and migration
*
Rephrasing scenarios : normalisation,
optimisation, refactoring, and renovation

r
Fo

Conceptual

al

rd
wa

Re-specify

e
ne

gi

Requirements

En
rin
g(

Re-design

Re

Design

ne
t)

en
m

ff

fi

Implementation

a

s

Types of Ch nge

Reengineering Process
Types of Ch nge
(Alteration)

Re-design

r
Fo

Conceptual

onceptual

rd
wa

Re-specify

e
ne

gi

Requirements

En

ments

The design characteristics of the software
are altered by re-designing the system.
Common changes to the software design
include:
I)
Restructuring the architecture
II) Modifying the data model of the system
III) Replacing a procedure or an algorithm
with a more e icient one

Re-think

rin
Re

Design

g(

Design

ne
t)

en
m

Implementation

fi

ff

tation

a

Re-code

Reengineering Process
Types of Change
(Alteration)

Re-specify

Re-think
Conceptual

ments

Requirements

En
e
ne

gi
rin

Design

fi
Re

Re-design

g(
ne
t)

en

m

tation

rd
wa

Design

This means changing the requirement
characteristics of the system in two ways:
1) change the form of the requirements
2) Change the scope of the requirements

r
Fo

onceptual

Re-code

Implementation

Change Requirement not adding requirement

Reengineering Process
Types of Change

rd
wa
gi

Requirements

En

Re-specify

* Re-thinking a system means manipulating the

r
Fo

Conceptual

onceptual

ments

Re-think

(Alteration)

ne
in

er

tation

Re-code

Implementation

t)

en

em

Design

fin
Re

Re-design

g(

Design

concepts embodied in an existing system that
operates in a different problem domain.
*
It involves changing the conceptual
characteristics of the system, and it can lead to
the system being changed in a fundamental way.
* Moving from the development of an ordinary
cellular phone to the development of smartphone
system is an example of Re-think.

Changing the whole concept

Reengineering Process
Software Reengineering Strategies

3 strategies specify the basic steps of reengineering are rewrite, rework, and replace

ne

Ab

t
en

m

st
ra
ct
io

LOOK AT THE ARROW FOR THE DIFFERENCE

fi
Re

n

Alteration

Existing System

Target System

Figure 4.2 Conceptual basis for the reengineering process, IEEE, 1992

Reengineering Process
Softw re Reengineering Str tegies

Rewrite strategy

a

a

fi

Existing System

Alteration

Target System

By means of alteration, an operational
system is transformed into a new
system, while preserving the
abstraction level of the original system.
For eg; the Fortan code of a system can
be rewritten in the C language.

Softw re Reengineering Str tegies
Rework strategy

- Applies all 3 principles
- Application of abstraction: By parsing

Alteration

st
ra
ct
io
Ab

t

en

m

a

fl

fl

fi

fl

a

Existing System

fi

the code, generate a control- ow graph
(CFG) for the given system
- Application of alteration: Apply a
restructuring algorithm to the controlow-graph to produce a structured
control- ow graph
- Application of re nement: Translate
the new, structured control- ow graph
back into the original programming
Target System
language

ne

n

Re

fl

Reengineering Process

Reengineering Process
Softw re Reengineering Str tegies

ne

st
ra
ct
io

n

Re

Ab

t

en

m

Target System

a

fi

fl

fl

a

fi

fi

fi

Existing System

Replace strategy

- Applies 2 principles (abstraction and
re nement)
- To change a certain characteristic of a
system:
- It is reconstructed at a higher level of
abstraction by hiding the details of
the characteristic
- A suitable representation for the
target system is generated at a lower
level of abstraction by applying
re nement
- By means of abstraction, a program is
represented at a higher level without
using control ow concepts
- By means of re nement, the system is
represented at a lower level of
abstraction with a new structured
control ow

Reengineering Process
Reengineering Variations
what you approach
Starting
Abstraction Level

Implementation
Level

Design Level

Requirement Level

Conceptual Level

Type
No of
Changes

Reengineering Strategy
Rewrite

Rework

Replace

Re-code

Yes

Yes

Yes

Re-design

Bad

Yes

Yes

Re-specify

Bad

Yes

Yes

Re-think

Bad

Yes*

Yes*

Re-code

No

No

No

Re-design

Yes

Yes

Yes

Re-specify

Bad

Yes

Yes

Re-think

Bad

Yes*

Yes*

Re-code

No

No

No

Re-design

No

No

No

Re-specify

Yes

Yes

Yes

Re-think

Bad

Yes*

Yes*

Re-code

No

No

No

Re-design

No

No

No

Re-specify

No

No

No

Re-think

Yes

Yes*

Yes*

Table 4.1 Reengineering process variations, IEEE, 1992

Yes - One can produce a target system
Yes* - Same as Yes, but the starting degree of abstraction
is lower than the uppermost degree of abstraction
within the conceptual abstraction level
No - One cannot start at abstraction level A, make B
type of changes by using strategy C, because the
starting abstraction level is higher than the abstraction
level required by the particular type of change
Bad - A target system can be created, but the likelihood
of achieving a good result is low

Reengineering Process
Reengineering Appro ches
Five approaches for software reengineering, are di er in two aspects:
1. The extent of reengineering performed
2. The rate of substitution of the operational system with the new one

Big Bang Approach
Incremental Approach
Partial Approach
Iterative Approach

ff

a

Evolutionary Approach

Approach

Description

Big Bang

Monolithic task, consuming signi cant
resources.

Incremental

This approach entails reengineering the system gradually with the
Easier error identi cation.
release of successive interim versions. It facilitates easier error
identi cation and allows customers to track progress, but it may
Visible progress for customers
take longer to complete, especially for complex systems.

Lengthy completion time.

Reengineering process is applied to the source code of a few
procedures at a time, ensuring continued system operation and
preserving user familiarity. However, it requires careful tracking
of multiple component types and maintenance of both old and
reengineered components.

Inability to change the entire system
architecture.

Lack of modi cations for the interface
between modi ed and non-modi ed
portions.

Ensures continued system
operation.

Requires tracking of multiple component
types.

Preserves user familiarity with the
system.

Maintenance of old and reengineered
components.

The approach substitutes original components with reengineered Enhanced design cohesion.
ones, focusing on functionally cohesive components. It then
identify and re ne similar functions throughout the operational Reduced scope of individual
components.
system.

a

ff

fi

fi

fi

fi

fi

fi

fi

Evolutionary

Time consuming for large systems.

Identi cation of similar functions throughout
the system.
Re ning functions as a unit in the new
system.

Reengineering Appro ches

The partial approach involves reengineering only a portion of the
system and integrating it with the non-reengineered part. It
Reduced reengineering scope and
reduces the scope of reengineering, resulting in cost and time
lower costs.
savings.

Iterative

fi

Disadvantages

The "Big Bang" approach involves replacing the entire system at
once. It is suitable for cases where reengineering cannot be done Quick transition to the new
environment
in parts, such as when migrating to a di erent system
architecture.

Partial

fi

Advantages

Approach

Description

Advantages

The "Big Bang" approach involves replacing the entire system at
once. It is suitable for cases where reengineering cannot be done Quick transition to the new
environment
in parts, such as when migrating to a di erent system
architecture.

Big Bang

Disadvantages

Eg; Migrating a legacy database
Monolithic task, consuming signi cant
resources.

system to a cloud-based architecture
in one go

Time consuming for large systems.

Reengineering Appro ches

Eg; Updating a mobile app in several

Incremental

phases, with each release

This approach entails reengineering the system gradually with the
Easier error identi cation.
release of successive interim versions. It facilitates easier error
identi cation and allows customers to track progress, but it may
Visible progress for customers
take longer to complete, especially for complex systems.

Lengthy completion time.

introducing new features

Inability to change the entire system
architecture.

Eg; Updating the UI of a website

The partial approach involves reengineering only a portion of the
system and integrating it with the non-reengineered part. It
Reduced reengineering scope and
reduces the scope of reengineering, resulting in cost and time
lower costs.
savings.

Partial

Reengineering process is applied to the source code of a few
procedures at a time, ensuring continued system operation and
preserving user familiarity. However, it requires careful tracking
of multiple component types and maintenance of both old and
reengineered components.

Iterative
Evolutionary

Ensures continued system
operation.

between modi ed and non-modi ed
portions.

functionalities

tracking of
multiple componentmodule
Eg;Requires
Re ning
e-commerce
types.

while keeping the website functional

Preserves user familiarity with the
system.

The approach substitutes original components with reengineered Enhanced design cohesion.
ones, focusing on functionally cohesive components. It then
identify and re ne similar functions throughout the operational Reduced scope of individual
components.
system.

Lack of modi altering
cations for theits
interface
without
backend

Maintenance of old and reengineered
components.

for users

Identi cation of similar functions throughout
the system.

Eg; Upgrading UI of a software for a
Re ning functions as a unit in the new
more
cohesive and user-friendly
system.

a

ff

fi

fi

fi

fi

fi

fi

fi

fi

fi

fi

experience

Software Reengineering Model
• General Model
• Horshoe Model
• Source code Reengineering Reference Model
• Phase Reengineering Model

Software Reengineering Model

(Alteration)

Gener l Model

Re-think

n)
tr
ac
tio
bs
(A
in

g(

gi

in

ne

er

er

ne

gi

Requirements

En

g

rd
wa

Requirements

Re-specify

r
Fo

Conceptual

Conceptual

Eric J. Byrne suggests
that reengineering is a
sequence of 3 activities:
Reverse engineering,
re-design, and forward
engineering

Design

Implementation

Re-code

Implementation

t)

en

m

Re
ve
r

ne

se

En

Re-design

Re

Design

Existing System
fi

a

Figure 4.3 General model of software reengineering, IEEE, 1992

Target System

Software Reengineering Model
Ex mple of reengineering

(Alteration)

Remove requirements
that are not needed in
the renovated system

Re-think
Conceptual

al

Re-specify

t

n

Requirement

Re-design

Design

Re-code

Implementatio

a

neral model of software reengineering, IEEE,

Recreate a design form
the existing source
code

Make a new design of
the desired system

Find the requirements of the
system being reengineered

Compare the existing
requirements with the
new ones
Code the new system
Target

Software Reengineering Model
Horshoe Model

Three distinct segment of the
horshoe are the left side, top part,
and the right side. Those three
parts denote the three steps of
the reengineering process

Figure 4.4 Horshoe model of software reengineering, IEEE, 1998

Software Reengineering Model
Source Code Reengineering Reference Model
The SCORE/RM model was
proposed by Colbrook, Smythe
and Darlison

Consists of 4 kinds of elements:
1. Function, Documentation,
Repository database, and
Metrication

Function element is divided into 8 layers
(Encapsulation, transformation,
normalisation, interpretation, abstraction,
causation, regeneration, and certi ication)

f

1.

Figure 4.5 Source code reengineering reference model, IEEE, 1990

Software Reengineering Model
Ph se Reengineering Model
The model was proposed by
Byrne and Gustafson

Comprises 5 phases:
1. Analysis and planning, renovation,
target system testing, re
documentation, and acceptance
testing and system transition

a

Figure 4.6 Software reengineering process phases, IEEE, 1992

Software Reengineering Model
Ph se Reengineering Model
Analysis and
Planning

Addresses 3 technical issues and 1 economic issue

3 technical issues :
present state of the system, identi cation for the need of reengineering, speci cation of the new system to be produced

1 economic issue : concerns a cost and bene t analysis of the reengineering project

Planning includes :
- understanding the scope, identifying resources, tasks, milestones,
estimating e ort, and preparing a schedule

Eg; Planning the reengineering of a legacy system by
analysing its present state and estimating the costs and

fi

fi

fi

ff

fi

a

bene ts

Software Reengineering Model
Ph se Reengineering Model
Operational systems are modi ed into
the target system. Consideration is
given to the representation of the
system and external data

Renovation

Eg; Upgrading a legacy system to from Fortran to C
through source-to-source translation, high level design

fi

a

construction or a mix of compilation and decompilation

Software Reengineering Model
Ph se Reengineering Model

Target System
Testing

Faults in the target system, introduced
during reengineering, are detected. Testing
strategies, techniques, and methods from
software development are employed.
Eg; Applying the existing system-level test cases to
both the existing and new systems to ensure identical

a

results.

Software Reengineering Model
Ph se Reengineering Model

Redocumentation

Documentations are rewritten or updated
to re ect the target system. - Revision of
requirement speci cations, design
documentation, and user manuals takes
place.
Eg; Updating the requirement speci cation and
design documentation to re ect the changes made

fi

fl

fi

fl

a

during the reengineering process

Software Reengineering Model
Ph se Reengineering Model

Acceptance and
System Transition

The reengineered system undergoes
acceptance testing. If the system fails tests,
necessary xes are implemented postdeployment. The reengineered system is
made operational while the old system is
decommissioned.
Eg; Evaluating the reengineered system through
acceptance tests and transitioning to the new system

fi

a

based on the pre-developed transition plan.

Reverse Engineering
• Code Reverse Engineering
• Data Reverse Engineering
• Technique used for Reverse Engineering
• Decompilation versus Reverse Engineering
• Reverse Engineering Tools

Reverse Engineering

Overview

1.

Originated in electrical engineering to produce schematics from circuits.

2. De ned as the process of developing speci cations for complex hardware
systems by examining specimens.
3. Chikofsky and Cross II de ned it as the process of identifying software
components and their relationships, representing the system at a higher level of
abstraction.
4. Aims at redocumentation and design recovery.
Applications of Reverse Engineering

•

Design recovery, detecting side e ects, facilitating
reuse, coping with complexity.
fi

Redocumentation of artifacts and generating
alternative views.

fi

•

ff

fi

Objectives

Transforming binary code into source code, redesigning user
interfaces, parallelizing programs, translating programs to
other languages, migrating data, extracting business rules,
wrapping legacy code, auditing security and vulnerability,
extracting network application protocols.

Reverse Engineering
Data Reverse
Engineering

Code Reverse
Engineering

fi

fi

In code reverse engineering, the process involves
partitioning the source code into units, creating input and
output schematics, and describing the system's internal
structure. This process aims to achieve objectives such as
redocumentation of artifacts and design recovery. It nds
application in various areas, including transforming
binary code into source code, redesigning user interfaces,
and auditing security and vulnerability.

Data reverse engineering involves the use of structured
techniques to reconstitute the data assets of an existing system.
The process revolves around recovering valuable data assets
and reconstituting them to enhance their utility. It entails
knowledge acquisition, documentation, integration, data
conversion, and quality assessment. The process of database
reverse engineering (DBRE) facilitates understanding and
redocumenting an application's database and les. It involves
the extraction of data structures and their conceptualization,
leading to the recreation of logical and conceptual schemas.

Lexical analysis

Control Flow
analysis

Decomposes source
code into lexical units
using lexical analysers,
often generated by tools
like lex and ex

Analyzes the
order of statement
execution within a
subprogram, constructing
control ow graphs
(CFGs) and call graphs
for intraprocedural

Syntax analysis

fi

fl

fi

fl

fi

Performed by parsers,
where the syntax of
programming languages is
described, and results can
be stored in a parse tree
or an abstract syntax
tree (AST)

ff

fl

Reverse Engineering

Data Flow
analysis
Focuses on how
values of de ned variables
ow through and are used
in a program, identifying
anomalies and providing
insights into program
execution.

Reverse Engineering Techniques
Program
slicing

Enables the extraction of program components
relevant to speci c criteria, either through
backward slicing (identifying program components
that a ect a selected computation) or forward
slicing ( nding program components impacted by
a selected computation).

Visualisation
Utilizes 3D
graphics and virtual
reality technology to
represent software
systems, allowing better
understanding of their
structure and

Program Metrics
Utilized to understand
and control the overall
software engineering
process, including various
metrics like complexity,
coupling, and
performance metrics.

Reverse Engineering
Software reverse engineering requires
tool support, complemented by human
intervention.

Reverse Engineering Tools

Tools provide a new perspective on the
product, enhancing understanding and
analysis.

Basic Structure of Reverse Engineering Tools

• Analysis of the software system to be reverse engineered.
• Results stored in an information base.
• View composers utilize the information base to generate
alternative views of the system.

Figure 4.16 Basic structure of reverse engineering tools ©IEEE 1990

Reverse Engineering
Reverse Engineering Tools
Tool Name

Description

Tool Name

Description

Ada SDA

Supports analysis and migration of Ada programs.

Java decompiler written in C++.

CodeCrawler

Language-independent tool combining metrics and
software visualization.

JAD (JAva
Decompiler)
ManSART

DMS (Design
Maintenance
System)
FermaT

Toolkit by Semantic Design, Inc, for re-engineering
medium or large-scale software systems.

Tool for recovering the architecture of a software
system.

McCabe IQ

Toolset designed by Software Migration Ltd. for
assembler code comprehension, maintenance, and
migration.
XML-based format for sharing data between tools,
representing various types of graphs.

Predicts issues in maintaining large and complex
business software applications.

PBS (Portable
Bookshelf )

Web-based implementation for navigating information
in large software systems.

RE-Analyzer

Automated reverse engineering system with integration
into a computer-aided software engineering (CASE)
tool.
Provides an interactive environment for reverse
engineering source code.

GXL (Graph
eXchange Language)
IDA Pro
Disassembler and
Debugger
Hex-Rays
Decompiler

Powerful disassembler supporting multiple processor
architectures.

Imagix 4D

Aids in understanding legacy C, C++, and Java
software.

IRAP (Input-Output
Reengineering and
Program Crafting)

Data reengineering tool by Spectra Research for
transforming legacy software into Intranet/Internet
enabled applications.

Commercial decompiler plug-in for IDA Pro.

Reengineering
Assistant (RA)
Rigi

Software tool for comprehending large software
systems through reverse engineering.

SEELA

Reverse engineering tool for documenting and
maintaining structured source code.

